import cv2
import numpy as np
import math

def process_frame(frame):
    roi = frame[100:550, 350:1000]

    gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(gray, (5, 5), 0)
    edges = cv2.Canny(blur, 50, 150, apertureSize=3)

    dilation = cv2.dilate(edges, np.array([5, 5]), iterations=20) 
    closing = cv2.morphologyEx(dilation, cv2.MORPH_CLOSE, np.array([9, 9]))
    erosion = cv2.erode(closing, np.array([5, 5]), iterations=10)  
    croi = roi.copy()
    lines = cv2.HoughLinesP(erosion, rho=1, theta=np.pi / 180, threshold=200, minLineLength=200, maxLineGap=500)

    line1lst = []
    line2lst = []

    if lines is not None:  
        x1, y1, x2, y2 = lines[0][0]
        slope = (y2 - y1) / (x2 - x1) if x2 != x1 else 999 
        tanbase = math.atan(slope)
        baseangle = tanbase * 180 / math.pi
        line1lst.append([(x1, y1), (x2, y2)])

        for line in lines[1:]:
            x1, y1, x2, y2 = line[0]
            slope = (y2 - y1) / (x2 - x1) if x2 != x1 else 999 
            tan = math.atan(slope)
            angle = tan * 180 / math.pi
            length = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)
            if length<500:
                if abs(int(baseangle - angle)) > 10:
                    line1lst.append([(x1, y1), (x2, y2)])
                else:
                    line2lst.append([(x1, y1), (x2, y2)])

        try:
            # Draw the lines
            cv2.line(croi, line1lst[0][0], line1lst[0][1], (0, 255, 0), 8)
            cv2.line(croi, line1lst[1][0], line1lst[1][1], (0, 255, 0), 8)

            # Reference point: Let's choose the center of the image as the reference point
            reference_point = (croi.shape[1] // 2, croi.shape[0] // 2)

            # Function to calculate Euclidean distance using np.linalg.norm
            def distance(p1, p2):
                return np.linalg.norm(np.array(p1) - np.array(p2))
            # Calculate bottom and top endpoints for line1
            x1, y1, x2, y2 = line1lst[0][0][0], line1lst[0][0][1], line1lst[0][1][0], line1lst[0][1][1]
            b_endpt_1 = (x1, y1) if distance((x1, y1), reference_point) > distance((x2, y2), reference_point) else (x2, y2)
            t_endpt_1 = (x1, y1) if distance((x1, y1), reference_point) < distance((x2, y2), reference_point) else (x2, y2)

            x1, y1, x2, y2 = line1lst[1][0][0], line1lst[1][0][1], line1lst[1][1][0], line1lst[1][1][1]
            # Compare distances to find the endpoint closest to the first line's endpoints
            if distance((x1, y1), b_endpt_1) < distance((x2, y2), b_endpt_1):
                b_endpt_2, t_endpt_2 = (x1, y1), (x2, y2)
            else:
                b_endpt_2, t_endpt_2 = (x2, y2), (x1, y1)

            # Draw the bottom and top endpoints
            cv2.circle(croi, b_endpt_1, 10, (255, 0, 0), -1)  # Blue dot at bottom endpoint of line1
            cv2.circle(croi, b_endpt_2, 10, (255, 0, 0), -1)  # Blue dot at bottom endpoint of line2
            cv2.circle(croi, t_endpt_1, 10, (0, 255, 255), -1)  # Yellow dot at top endpoint of line1
            cv2.circle(croi, t_endpt_2, 10, (0, 255, 255), -1)  # Yellow dot at top endpoint of line2


            # Calculate and draw the midpoints
            midpoint1 = ((line1lst[0][0][0] + line1lst[0][1][0]) // 2, (line1lst[0][0][1] + line1lst[0][1][1]) // 2)
            midpoint2 = ((line1lst[1][0][0] + line1lst[1][1][0]) // 2, (line1lst[1][0][1] + line1lst[1][1][1]) // 2)

            # Draw a dot at the center of line1 and line2 (midpoints)
            cv2.circle(croi, midpoint1, 10, (0, 0, 255), -1)  # Red dot at midpoint of line1
            cv2.circle(croi, midpoint2, 10, (0, 0, 255), -1)  # Red dot at midpoint of line2
            
            c1 = ((midpoint1[0] + midpoint2[0]) // 2, (midpoint1[1] + midpoint2[1]) // 2)
            c2 = ((b_endpt_1[0] + b_endpt_2[0]) // 2, (b_endpt_1[1] + b_endpt_2[1]) // 2)
            c3 = ((t_endpt_1[0] + t_endpt_2[0]) // 2, (t_endpt_1[1] + t_endpt_2[1]) // 2)     
            cv2.circle(croi, c1, 10, (42, 42, 165), -1)  
            cv2.circle(croi, c2, 10, (42, 42, 165), -1) 
            cv2.circle(croi, c3, 10, (42, 42, 165), -1)

            points = np.array([c1, c2, c3], np.int32)  # Create an array of points to form a polyline
            points = points.reshape((-1, 1, 2))  # Reshape for polylines
            cv2.polylines(croi, [points], isClosed=False, color=(0, 255, 255), thickness=2)  # Draw the line

        except Exception as e:
            print(f"Error: {e}")

    # Update the processed ROI in the frame
    frame[100:550, 350:1000] = croi
    return frame

cap = cv2.VideoCapture(0)

if not cap.isOpened():
    print("uh oh error")
    exit()

while True:
    ret, frame = cap.read()
    if not ret:
        break

    processed_frame = process_frame(frame)

    # Drawing ROI
    cv2.rectangle(processed_frame, (350, 100), (1000, 550), (0, 255, 0), 2)

    # Showing processed frame
    cv2.imshow("detection", processed_frame)

    # Exit by pressing "q"
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()

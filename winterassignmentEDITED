import cv2
import numpy as np

def process_frame(frame):
    #cropping the frame to fit the ROI
    roi = frame[100:600, 250:1100]  

    #enhancing the frame
    #applying grayscale
    gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)

    #applying gaussian blur
    blur = cv2.GaussianBlur(gray, (5, 5), 0)

    #finding the threshold for contours, converts it into binary image
    _, thresh = cv2.threshold(blur, 150, 255, cv2.THRESH_BINARY)

    #searching for contours
    contours, _ = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)

    #creating a copy of roi
    roi_copy = roi.copy()

    #making a list for detected curves
    curves = []
 

    for contour in contours:
        #calculates the area of each contour
        area = cv2.contourArea(contour)
        #filters irrelevant ones (too big or too small)
        if 2000 < area < 10000:
            #finding perimeter of contour
            peri = cv2.arcLength(contour, True)
            #simplifying for straight lines
            epsilon = 0.03 * peri
            #approximating each contour
            approx = cv2.approxPolyDP(contour, epsilon, True)
            #filters out contours that aren't lines
            if len(approx) <= 2:
                curves.append(approx)
                cv2.drawContours(roi_copy, [approx], -1, (0, 255, 0), 2)

    #averaging first 2 lines if there are only 2 lines detected to find the centerline
    if len(curves) >= 2:
        #making a list for detected midpts
        midpts = []

        #reshaping into a 2D array
        curve1_pts = curves[0].reshape(-1, 2)
        curve2_pts = curves[1].reshape(-1, 2)

        #calculating the shortest line size
        min_size = min(len(curve1_pts), len(curve2_pts))
        
        #cropping each line to fit the shortest line size
        curve1_pts = curve1_pts[:min_size]
        curve2_pts = curve2_pts[:min_size]

        #matching each element from curve1 to curve2 to find the closest pt (makes sure that its going to append to proper midpt)
        for pt in curve1_pts:
            #finding the distance between each pt and curve2
            dist = np.linalg.norm (curve2_pts - pt, axis = 1)
            #finding index 
            i = np.argmin(dist, axis = None, out = None)
            #finding the 2nd pt
            pt2 = curve2_pts[i]

            #calculating midpt using 2 pts
            midpt = (pt + pt2) // 2
            midpts.append(midpt)
        #drawing it out

        #making it a np array again
        midpts = np.array(midpts)
        #reshaping
        midpts = midpts.reshape(-1, 1, 2)
        #drawing
        cv2.drawContours(roi_copy, [midpts], -1, (255, 0, 0), 2)
   
    #puting updated processed roi into frame
    frame[100:600, 250:1100] = roi_copy
    return frame


cap = cv2.VideoCapture(0)

if not cap.isOpened():
    print("uh oh error")
    exit()

while True:
    ret, frame = cap.read()
    if not ret:
        break

    processed_frame = process_frame(frame)

    #drawing ROI
    cv2.rectangle(processed_frame, (250, 100), (1100, 600), (0, 255, 0), 2)

    #showing processed frame
    cv2.imshow("detection", processed_frame)

    #exit by pressing "q"
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()
